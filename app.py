"""
FastAPI web application for RAG (Retrieval-Augmented Generation) system.
Provides a user-friendly web interface for PDF management and querying.
"""

import os
import shutil
from typing import List, Optional
from datetime import datetime
from fastapi import FastAPI, File, UploadFile, Form, HTTPException, Request
from fastapi.responses import HTMLResponse, JSONResponse, StreamingResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from pydantic import BaseModel

# Import RAG modules
from utils.pdf_manage import get_pdf_names, insert_pdf, set_active_pdfs, query_pdfs_async, query_pdfs_stream_async
from rag_modules.clear import clear_database
from utils.colored_logger import get_colored_logger

logger = get_colored_logger(__name__)

# Initialize FastAPI app
app = FastAPI(title="RAG System", description="PDF-based Retrieval-Augmented Generation System")

# Create necessary directories
os.makedirs("static", exist_ok=True)
os.makedirs("templates", exist_ok=True)
os.makedirs("uploads", exist_ok=True)
os.makedirs("docs", exist_ok=True)  # Ensure docs directory exists
os.makedirs("answers", exist_ok=True)  # Directory for saving LLM outputs

# Mount static files and templates
app.mount("/static", StaticFiles(directory="static"), name="static")
app.mount("/docs", StaticFiles(directory="docs"), name="docs")  # Add docs directory for images
templates = Jinja2Templates(directory="templates")

# Global state for active PDFs (in production, use session management)
active_pdfs = []

def save_answer_to_file(query: str, answer: str, used_pdfs: List[str]) -> str:
    """Save LLM answer to a file in ./answers directory"""
    try:
        # Create timestamp for filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        # Sanitize query for filename (remove special characters)
        safe_query = "".join(c for c in query[:50] if c.isalnum() or c in (' ', '-', '_')).rstrip()
        safe_query = safe_query.replace(' ', '_')
        
        filename = f"{timestamp}_{safe_query}.md"
        filepath = os.path.join("answers", filename)
        
        # Create content with metadata
        content = f"""# Query Response - {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

## Query
{query}

## Used PDFs
{', '.join(used_pdfs)}

## Answer
{answer}

---
*Generated by RAG System*
"""
        
        # Write to file
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(content)
        
        logger.info(f"Answer saved to: {filepath}")
        return filename
        
    except Exception as e:
        logger.error(f"Error saving answer to file: {e}")
        return ""

# Pydantic models
class QueryRequest(BaseModel):
    query: str
    active_pdfs: List[str]

class SetActivePDFsRequest(BaseModel):
    pdf_names: List[str]

class APIResponse(BaseModel):
    success: bool
    message: str
    data: Optional[dict] = None

@app.get("/", response_class=HTMLResponse)
async def home(request: Request):
    """Main page with all RAG functionalities"""
    try:
        pdf_list = list(get_pdf_names())
        return templates.TemplateResponse("index.html", {
            "request": request,
            "pdf_list": pdf_list,
            "active_pdfs": active_pdfs
        })
    except Exception as e:
        logger.error(f"Error loading home page: {e}")
        return HTMLResponse(f"<h1>Error loading page: {e}</h1>", status_code=500)

# 1. Import PDF functionality
@app.post("/upload-pdf")
async def upload_pdf(file: UploadFile = File(...)):
    """Upload and process a PDF file"""
    try:
        if not file.filename.endswith('.pdf'):
            raise HTTPException(status_code=400, detail="Only PDF files are allowed")
        
        # Save uploaded file
        upload_path = os.path.join("uploads", file.filename)
        with open(upload_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
        
        # Process the PDF
        success = insert_pdf(upload_path)
        
        if success:
            return APIResponse(
                success=True, 
                message=f"Successfully uploaded and processed {file.filename}",
                data={"filename": file.filename}
            )
        else:
            raise HTTPException(status_code=500, detail="Failed to process PDF")
            
    except Exception as e:
        logger.error(f"Error uploading PDF: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# 2. List imported PDFs functionality  
@app.get("/api/pdfs")
async def list_pdfs():
    """Get list of all imported PDF names"""
    try:
        pdf_names = list(get_pdf_names())
        return APIResponse(
            success=True,
            message="Retrieved PDF list successfully",
            data={"pdfs": pdf_names}
        )
    except Exception as e:
        logger.error(f"Error getting PDF list: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# 3. Set active PDFs functionality
@app.post("/api/set-active-pdfs")
async def set_active_pdfs_endpoint(request: SetActivePDFsRequest):
    """Set which PDFs should be currently used for querying"""
    try:
        global active_pdfs
        active_pdfs = request.pdf_names
        success = set_active_pdfs(request.pdf_names)
        
        if success:
            return APIResponse(
                success=True,
                message=f"Successfully set {len(request.pdf_names)} PDFs as active",
                data={"active_pdfs": request.pdf_names}
            )
        else:
            raise HTTPException(status_code=500, detail="Failed to set active PDFs")
            
    except Exception as e:
        logger.error(f"Error setting active PDFs: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# 4. Query functionality
@app.post("/api/query")
async def query_endpoint(request: QueryRequest):
    """Answer user's question based on selected PDFs"""
    try:
        if not request.active_pdfs:
            raise HTTPException(status_code=400, detail="No PDFs selected for querying")
        
        answer = await query_pdfs_async(request.query, request.active_pdfs)
        
        # Save answer to file
        saved_filename = save_answer_to_file(request.query, answer, request.active_pdfs)
        
        return APIResponse(
            success=True,
            message="Query processed successfully",
            data={
                "query": request.query,
                "answer": answer,
                "used_pdfs": request.active_pdfs,
                "saved_file": saved_filename
            }
        )
    except Exception as e:
        logger.error(f"Error processing query: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# 4.1. Streaming Query functionality
@app.post("/api/query/stream")
async def query_stream_endpoint(request: QueryRequest):
    """Stream answer for user's question based on selected PDFs"""
    try:
        if not request.active_pdfs:
            raise HTTPException(status_code=400, detail="No PDFs selected for querying")
        
        # Collect full answer for saving
        full_answer = ""
        
        async def generate_stream():
            nonlocal full_answer
            try:
                async for chunk in query_pdfs_stream_async(request.query, request.active_pdfs):
                    if chunk:
                        # Accumulate chunks for saving
                        full_answer += chunk
                        # Ensure proper SSE format
                        yield f"data: {chunk}\n\n"
                
                # Save the complete answer after streaming is done
                if full_answer.strip():
                    saved_filename = save_answer_to_file(request.query, full_answer, request.active_pdfs)
                    logger.info(f"Streaming answer saved to: {saved_filename}")
                
                yield "data: [DONE]\n\n"  # Signal completion
            except Exception as e:
                logger.error(f"Error in stream generation: {e}")
                yield f"data: Error: {str(e)}\n\n"
        
        return StreamingResponse(
            generate_stream(),
            media_type="text/plain",
            headers={
                "Cache-Control": "no-cache",
                "Connection": "keep-alive",
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "*",
                "X-Accel-Buffering": "no"  # Disable nginx buffering
            }
        )
    except Exception as e:
        logger.error(f"Error processing streaming query: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# 5. Clear database functionality
@app.delete("/api/clear")
async def clear_all_data():
    """Clear all imported PDFs from the database"""
    try:
        clear_database()
        global active_pdfs
        active_pdfs = []
        
        return APIResponse(
            success=True,
            message="Successfully cleared all data from database"
        )
    except Exception as e:
        logger.error(f"Error clearing database: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# Health check endpoint
@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "message": "RAG system is running"}

# List saved answers endpoint
@app.get("/api/answers")
async def list_saved_answers():
    """List all saved answer files"""
    try:
        answers_dir = "answers"
        answer_files = []
        
        if os.path.exists(answers_dir):
            for filename in os.listdir(answers_dir):
                if filename.endswith('.md'):
                    filepath = os.path.join(answers_dir, filename)
                    stat = os.stat(filepath)
                    
                    answer_files.append({
                        "filename": filename,
                        "path": filepath,
                        "size": stat.st_size,
                        "created": datetime.fromtimestamp(stat.st_ctime).strftime("%Y-%m-%d %H:%M:%S"),
                        "modified": datetime.fromtimestamp(stat.st_mtime).strftime("%Y-%m-%d %H:%M:%S")
                    })
        
        # Sort by creation time (newest first)
        answer_files.sort(key=lambda x: x['created'], reverse=True)
        
        return APIResponse(
            success=True,
            message=f"Found {len(answer_files)} saved answers",
            data={"answers": answer_files}
        )
    except Exception as e:
        logger.error(f"Error listing saved answers: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# Test endpoint for checking image accessibility
@app.get("/test-images")
async def test_images():
    """Test endpoint to list available images"""
    try:
        images = []
        docs_path = "docs"
        if os.path.exists(docs_path):
            for root, dirs, files in os.walk(docs_path):
                for file in files:
                    if file.lower().endswith(('.jpg', '.jpeg', '.png', '.gif')):
                        rel_path = os.path.relpath(os.path.join(root, file), docs_path)
                        images.append({
                            "filename": file,
                            "path": f"/docs/{rel_path}",
                            "full_path": os.path.join(root, file)
                        })
        
        return APIResponse(
            success=True,
            message=f"Found {len(images)} images",
            data={"images": images}
        )
    except Exception as e:
        logger.error(f"Error listing images: {e}")
        return APIResponse(
            success=False,
            message=str(e)
        )

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)