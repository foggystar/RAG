"""
FastAPI web application for RAG (Retrieval-Augmented Generation) system.
Provides a user-friendly web interface for PDF management and querying.
"""

import os
import shutil
from typing import List, Optional
from datetime import datetime
from fastapi import FastAPI, File, UploadFile, HTTPException, Request
from fastapi.responses import HTMLResponse, StreamingResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from pydantic import BaseModel

# Import RAG modules
from utils.pdf_manage import get_pdf_names, insert_pdf, set_active_pdfs, query_pdfs_async, query_pdfs_stream_async, delete_pdf
from rag_modules.clear import clear_database
from rag_modules import get_database
from utils.colored_logger import get_colored_logger, logging

logger = get_colored_logger(__name__, level=logging.DEBUG)

# Initialize FastAPI app
app = FastAPI(title="RAG System", description="PDF-based Retrieval-Augmented Generation System")

# Create necessary directories
os.makedirs("static", exist_ok=True)
os.makedirs("templates", exist_ok=True)
os.makedirs("uploads", exist_ok=True)
os.makedirs("docs", exist_ok=True)  # Ensure docs directory exists

# Mount static files and templates
app.mount("/static", StaticFiles(directory="static"), name="static")
app.mount("/docs", StaticFiles(directory="docs"), name="docs")  # Add docs directory for images
app.mount("/uploads", StaticFiles(directory="uploads"), name="uploads")  # Add uploads directory for processed PDFs
templates = Jinja2Templates(directory="templates")

# Global state for active PDFs (in production, use session management)
active_pdfs = []

def save_answer_to_file(query: str, answer: str, used_pdfs: List[str]) -> str:
    """Save LLM answer to a file in ./uploads directory"""
    try:
        # Create timestamp for filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        # Sanitize query for filename (remove special characters)
        safe_query = "".join(c for c in query[:50] if c.isalnum() or c in (' ', '-', '_')).rstrip()
        safe_query = safe_query.replace(' ', '_')
        
        filename = f"{timestamp}_{safe_query}.md"
        filepath = os.path.join("uploads", filename)
        
        # Create content with metadata
        content = f"""# Query Response - {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

## Query
{query}

## Used PDFs
{', '.join(used_pdfs)}

## Answer
{answer}

---
*Generated by RAG System*
"""
        
        # Write to file
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(content)
        
        logger.info(f"Answer saved to: {filepath}")
        return filename
        
    except Exception as e:
        logger.error(f"Error saving answer to file: {e}")
        return ""

# Pydantic models
class QueryRequest(BaseModel):
    query: str
    active_pdfs: List[str]

class SetActivePDFsRequest(BaseModel):
    pdf_names: List[str]

class APIResponse(BaseModel):
    success: bool
    message: str
    data: Optional[dict] = None

@app.get("/", response_class=HTMLResponse)
async def home(request: Request):
    """Main page with all RAG functionalities"""
    try:
        get_database.get_database_client() # 重新获取数据库客户端
        pdf_list = list(get_pdf_names())
        return templates.TemplateResponse("index.html", {
            "request": request,
            "pdf_list": pdf_list,
            "active_pdfs": active_pdfs
        })
    except Exception as e:
        logger.error(f"Error loading home page: {e}")
        return HTMLResponse(f"<h1>Error loading page: {e}</h1>", status_code=500)

# 1. Import PDF functionality
@app.post("/upload-pdf")
async def upload_pdf(file: UploadFile = File(...)):
    """Upload and process a PDF file"""
    try:
        if not file.filename.endswith('.pdf'):
            raise HTTPException(status_code=400, detail="Only PDF files are allowed")

        # 安全处理文件名，防止路径穿越
        import uuid
        import re
        
        # 获取文件扩展名
        ext = '.pdf'
        
        # 清理文件名，只保留安全字符
        base_name = os.path.splitext(os.path.basename(file.filename))[0]
        safe_base_name = re.sub(r'[^a-zA-Z0-9._-]', '_', base_name)
        
        # 如果文件名为空或只有特殊字符，使用UUID
        if not safe_base_name or safe_base_name.startswith('.'):
            safe_filename = f"{uuid.uuid4().hex}{ext}"
        else:
            safe_filename = f"{safe_base_name}{ext}"
        # 确保文件名不会太长
        if len(safe_filename) > 255:
            name_part = safe_filename[:250-len(ext)]
            safe_filename = f"{name_part}{ext}"
        
        # 构建安全的上传路径
        upload_path = os.path.join("uploads", safe_filename)
        
        # 额外检查：确保最终路径仍在uploads目录内
        upload_dir = os.path.abspath("uploads")
        final_path = os.path.abspath(upload_path)
        
        if not final_path.startswith(upload_dir):
            raise HTTPException(status_code=400, detail="Invalid file path")
        
        # 检查文件是否已存在，如果存在则添加序号
        counter = 1
        while os.path.exists(upload_path):
            name, ext = os.path.splitext(safe_filename)
            safe_filename = f"{name}_{counter}{ext}"
            upload_path = os.path.join("uploads", safe_filename)
            counter += 1

        # Save uploaded file
        # upload_path = os.path.join("uploads", file.filename)
        with open(upload_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
        
        # Process the PDF
        success = await insert_pdf(upload_path)
        
        if success:
            return APIResponse(
                success=True, 
                message=f"Successfully uploaded and processed {file.filename}",
                data={"filename": file.filename}
            )
        else:
            raise HTTPException(status_code=500, detail="Failed to process PDF")
            
    except Exception as e:
        logger.error(f"Error uploading PDF: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# 2. List imported PDFs functionality  
@app.get("/api/pdfs")
async def list_pdfs():
    """Get list of all imported PDF names"""
    try:
        pdf_names = list(get_pdf_names())
        return APIResponse(
            success=True,
            message="Retrieved PDF list successfully",
            data={"pdfs": pdf_names}
        )
    except Exception as e:
        logger.error(f"Error getting PDF list: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# 3. Set active PDFs functionality
@app.post("/api/set-active-pdfs")
async def set_active_pdfs_endpoint(request: SetActivePDFsRequest):
    """Set which PDFs should be currently used for querying"""
    try:
        global active_pdfs
        active_pdfs = request.pdf_names
        success = set_active_pdfs(request.pdf_names)
        
        if success:
            return APIResponse(
                success=True,
                message=f"Successfully set {len(request.pdf_names)} PDFs as active",
                data={"active_pdfs": request.pdf_names}
            )
        else:
            raise HTTPException(status_code=500, detail="Failed to set active PDFs")
            
    except Exception as e:
        logger.error(f"Error setting active PDFs: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# 3.1. Delete specific PDF functionality
@app.delete("/api/pdfs/{pdf_name}")
async def delete_pdf_endpoint(pdf_name: str):
    """Delete a specific PDF and all its associated data from the database"""
    try:
        global active_pdfs
        
        # Check if PDF exists first
        existing_pdfs = list(get_pdf_names())
        if pdf_name not in existing_pdfs:
            raise HTTPException(status_code=404, detail=f"PDF '{pdf_name}' not found")
        
        # Remove from active PDFs if it's currently active
        if pdf_name in active_pdfs:
            active_pdfs.remove(pdf_name)
            logger.info(f"Removed '{pdf_name}' from active PDFs list")
        
        # Delete the PDF
        success = delete_pdf(pdf_name)
        
        if success:
            return APIResponse(
                success=True,
                message=f"Successfully deleted PDF '{pdf_name}' and all associated data",
                data={"deleted_pdf": pdf_name, "remaining_active_pdfs": active_pdfs}
            )
        else:
            raise HTTPException(status_code=500, detail=f"Failed to delete PDF '{pdf_name}'")
            
    except HTTPException:
        raise  # Re-raise HTTP exceptions as-is
    except Exception as e:
        logger.error(f"Error deleting PDF '{pdf_name}': {e}")
        raise HTTPException(status_code=500, detail=str(e))

# 4. Query functionality
@app.post("/api/query")
async def query_endpoint(request: QueryRequest):
    """Answer user's question based on selected PDFs"""
    try:
        if not request.active_pdfs:
            raise HTTPException(status_code=400, detail="No PDFs selected for querying")
        
        answer = await query_pdfs_async(request.query, request.active_pdfs)
        
        # Save answer to file
        saved_filename = save_answer_to_file(request.query, answer, request.active_pdfs)
        
        return APIResponse(
            success=True,
            message="Query processed successfully",
            data={
                "query": request.query,
                "answer": answer,
                "used_pdfs": request.active_pdfs,
                "saved_file": saved_filename
            }
        )
    except Exception as e:
        logger.error(f"Error processing query: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# 4.1. Streaming Query functionality
@app.post("/api/query/stream")
async def query_stream_endpoint(request: QueryRequest):
    """Stream answer for user's question based on selected PDFs"""
    try:
        if not request.active_pdfs:
            raise HTTPException(status_code=400, detail="No PDFs selected for querying")
        
        # Collect full answer for saving
        full_answer = ""
        
        async def generate_stream():
            nonlocal full_answer
            try:
                async for chunk in query_pdfs_stream_async(request.query, request.active_pdfs):
                    if chunk:
                        # Accumulate chunks for saving
                        full_answer += chunk
                        # Ensure proper SSE format
                        yield f"data: {chunk}\n\n"
                
                # Save the complete answer after streaming is done
                if full_answer.strip():
                    saved_filename = save_answer_to_file(request.query, full_answer, request.active_pdfs)
                    logger.info(f"Streaming answer saved to: {saved_filename}")
                
                yield "data: [DONE]\n\n"  # Signal completion
            except Exception as e:
                logger.error(f"Error in stream generation: {e}")
                yield f"data: Error: {str(e)}\n\n"
        
        return StreamingResponse(
            generate_stream(),
            media_type="text/plain",
            headers={
                "Cache-Control": "no-cache",
                "Connection": "keep-alive",
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "*",
                "X-Accel-Buffering": "no"  # Disable nginx buffering
            }
        )
    except Exception as e:
        logger.error(f"Error processing streaming query: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# 5. Clear database functionality
@app.delete("/api/clear")
async def clear_all_data():
    """Clear all imported PDFs from the database"""
    try:
        clear_database()
        global active_pdfs
        active_pdfs = []
        
        return APIResponse(
            success=True,
            message="Successfully cleared all data from database"
        )
    except Exception as e:
        logger.error(f"Error clearing database: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# Health check endpoint
@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "message": "RAG system is running"}

# List saved answers endpoint
@app.get("/api/answers")
async def list_saved_answers():
    """List all saved answer files"""
    try:
        answers_dir = "uploads"
        answer_files = []
        
        if os.path.exists(answers_dir):
            for filename in os.listdir(answers_dir):
                if filename.endswith('.md'):
                    filepath = os.path.join(answers_dir, filename)
                    stat = os.stat(filepath)
                    
                    answer_files.append({
                        "filename": filename,
                        "path": filepath,
                        "size": stat.st_size,
                        "created": datetime.fromtimestamp(stat.st_ctime).strftime("%Y-%m-%d %H:%M:%S"),
                        "modified": datetime.fromtimestamp(stat.st_mtime).strftime("%Y-%m-%d %H:%M:%S")
                    })
        
        # Sort by creation time (newest first)
        answer_files.sort(key=lambda x: x['created'], reverse=True)
        
        return APIResponse(
            success=True,
            message=f"Found {len(answer_files)} saved answers",
            data={"answers": answer_files}
        )
    except Exception as e:
        logger.error(f"Error listing saved answers: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# Test endpoint for checking image accessibility
@app.get("/test-images")
async def test_images():
    """Test endpoint to list available images"""
    try:
        images = []
        docs_path = "docs"
        if os.path.exists(docs_path):
            for root, dirs, files in os.walk(docs_path):
                for file in files:
                    if file.lower().endswith(('.jpg', '.jpeg', '.png', '.gif')):
                        rel_path = os.path.relpath(os.path.join(root, file), docs_path)
                        images.append({
                            "filename": file,
                            "path": f"/docs/{rel_path}",
                            "full_path": os.path.join(root, file)
                        })
        
        return APIResponse(
            success=True,
            message=f"Found {len(images)} images",
            data={"images": images}
        )
    except Exception as e:
        logger.error(f"Error listing images: {e}")
        return APIResponse(
            success=False,
            message=str(e)
        )

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="127.0.0.1", port=8000)